<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2K.1beta (1.48)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Irregular Structure</TITLE>
<META NAME="description" CONTENT="Irregular Structure">
<META NAME="keywords" CONTENT="performance">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="performance.css">

<LINK REL="next" HREF="node13.html">
<LINK REL="previous" HREF="node11.html">
<LINK REL="up" HREF="node2.html">
<LINK REL="next" HREF="node13.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html154"
  HREF="node13.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="icons/next.png"></A> 
<A NAME="tex2html152"
  HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="icons/up.png"></A> 
<A NAME="tex2html146"
  HREF="node11.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html155"
  HREF="node13.html">Join Selectivity</A>
<B> Up:</B> <A NAME="tex2html153"
  HREF="node2.html">Performance Analysis Using the</A>
<B> Previous:</B> <A NAME="tex2html147"
  HREF="node11.html">Complex Pattern Selectivity</A>
<BR>
<BR>
<!--End of Navigation Panel-->

<H3><A NAME="SECTION000021000000000000000">
Irregular Structure</A>
</H3>
Since some parts of an XML document may have irregular data structure, such 
as missing elements, queries such as QS35 are useful when looking for such 
irregularities. Query QS35 looks for all <I>BaseType</I> elements below which
there is no <I>OccasionalType</I> element.

<P>
In TIMBER, this operation is very fast because it uses a variation of the
structural joins used in evaluating containment queries. This join outputs
ancestors that <I>do not</I> have a matching descendant.  

<P>
In the ORDBMS, this query takes a very long time to finish because the 
ORDBMS first needs to find a set of elements that contain the missing elements (a
recursive SQL query is used for this part), and 
then find elements that are not in that set (using a set difference operation). 
This is inefficient compared to the structural join algorithm that TIMBER  uses.

<P>
<BR><HR>
</BODY>
</HTML>
